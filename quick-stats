#!/usr/bin/env Rscript

library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(ggplot2, quietly = TRUE, warn.conflicts = FALSE)
library(readr, quietly = TRUE, warn.conflicts = FALSE)

source(file = './lib/style.R')

logTicks <- function(n = 5, base = 10){
  # Divisors of the logarithm base. E.g. for base 10: 1, 2, 5, 10.
  divisors <- which((base / seq_len(base)) %% 1 == 0)
  mkTcks <- function(min, max, base, divisor){
    f <- seq(divisor, base, by = divisor)
    return(unique(c(base^min, as.vector(outer(f, base^(min:max), `*`)))))
  }

  function(x) {
    rng <- range(x, na.rm = TRUE)
    lrng <- log(rng, base = base)
    min <- floor(lrng[1])
    max <- ceiling(lrng[2])

    tck <- function(divisor){
      t <- mkTcks(min, max, base, divisor)
      t[t >= rng[1] & t <= rng[2]]
    }
    # For all possible divisors, produce a set of ticks and count how many ticks
    # result
    tcks <- lapply(divisors, function(d) tck(d))
    l <- vapply(tcks, length, numeric(1))

    # Take the set of ticks which is nearest to the desired number of ticks
    i <- which.min(abs(n - l))
    if(l[i] < 2){
      # The data range is too small to show more than 1 logarithm tick, fall
      # back to linear interpolation
      ticks <- pretty(x, n = n, min.n = 2)
    }else{
      ticks <- tcks[[i]]
    }
    return(ticks)
  }
}

log10_diminishing_breaks = function(...) {
  function(x) {
    minx = floor(min(log10(x), na.rm = T)) - 1;
    maxx = ceiling(max(log10(x), na.rm = T)) + 1;
    n_major = maxx - minx + 1;
    major_breaks = seq(minx, maxx, by = 1)
    minor_breaks =
      rep(log10(seq(1, 9, by = 1)), times = n_major) +
      rep(major_breaks, each = 9)
    return(10^minor_breaks)
  }
}

data = suppressMessages(readr::read_csv(
  file('stdin'),
  col_names = FALSE,
))

if(ncol(data) == 1) {
  data = mutate(data, val = X1)
} else {
  data = mutate(data, group = X1, val = X2) %>% group_by(group)
}

summary = summarize_at(
  data,
  vars(val),
  list(
    ~mean(.),
    ~median(.),
    ~sd(.),
    ~n()
  )
) #%>% format_csv(na = '') %>% cat

ggplot(data, aes(x = reorder(group, val, FUN=median), y = val)) +
  geom_boxplot() +
  # geom_text(data = summary, aes(x = group, y = 0, label = mean, hjust = 'left')) +
  xlab('job class') +
  ylab('runtime (seconds)') +
  scale_y_log10(
    breaks = scales::log_breaks(),
    minor_breaks = log10_diminishing_breaks(),
    labels = scales::comma_format(accuracy = 0.1),
    sec.axis = dup_axis(),
  ) +
  coord_flip()
ggsave('plot.pdf',
  width = 10,
  height = min(c(49, 7 * (n_groups(data) / 8))),
)
